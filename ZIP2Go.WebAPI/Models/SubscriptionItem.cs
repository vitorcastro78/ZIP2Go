/*
 * Quickstart API Reference
 *
 * Zuora Quickstart API is recommended for new customers and integrators, allowing new integrators to swiftly integrate with Zuora. It supports essential business use cases.   To use the Quickstart API, you must have the following features enabled on your tenant:   * [Orders](https://knowledgecenter.zuora.com/Billing/Subscriptions/Orders) or [Orders Harmonization](https://knowledgecenter.zuora.com/Billing/Subscriptions/Orders/Orders_Harmonization)  * [Invoice Settlement](https://knowledgecenter.zuora.com/Billing/Billing_and_Payments/Invoice_Settlement)  To find the latest changes made to the Zuora Quickstart API, check the [Quickstart API Changelog](https://developer.zuora.com/quickstart-api/changelog/2022q4-changelog/).  We recommend that you subscribe to [Developers Community](https://community.zuora.com/communities/community-home?communitykey=e2a932b4-50c4-4019-a3e8-362e38714df3) to get notifications when a new version is released.  
 *
 * OpenAPI spec version: 2024-01-10
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace ZIP2Go.WebAPI.Models
{
    /// <summary>
    /// Subscription item information.
    /// </summary>
    [DataContract]
    public partial class SubscriptionItem : IEquatable<SubscriptionItem>
    { 
        /// <summary>
        /// Unique identifier for the object.
        /// </summary>
        /// <value>Unique identifier for the object.</value>

        [DataMember(Name="id")]
        public string Id { get; private set; }

        /// <summary>
        /// Unique identifier of the Zuora user who last updated the object
        /// </summary>
        /// <value>Unique identifier of the Zuora user who last updated the object</value>

        [DataMember(Name="updated_by_id")]
        public string UpdatedById { get; private set; }

        /// <summary>
        /// The date and time when the object was last updated in ISO 8601 UTC format.
        /// </summary>
        /// <value>The date and time when the object was last updated in ISO 8601 UTC format.</value>

        [DataMember(Name="updated_time")]
        public DateTime? UpdatedTime { get; private set; }

        /// <summary>
        /// Unique identifier of the Zuora user who created the object
        /// </summary>
        /// <value>Unique identifier of the Zuora user who created the object</value>

        [DataMember(Name="created_by_id")]
        public string CreatedById { get; private set; }

        /// <summary>
        /// The date and time when the object was created in ISO 8601 UTC format.
        /// </summary>
        /// <value>The date and time when the object was created in ISO 8601 UTC format.</value>

        [DataMember(Name="created_time")]
        public DateTime? CreatedTime { get; private set; }

        /// <summary>
        /// Set of user-defined fields associated with this object. Useful for storing additional information about the object in a structured format.
        /// </summary>
        /// <value>Set of user-defined fields associated with this object. Useful for storing additional information about the object in a structured format.</value>

        [DataMember(Name="custom_fields")]
        public Dictionary<string, Object> CustomFields { get; set; }

        /// <summary>
        /// The custom objects associated with a Zuora standard object.
        /// </summary>
        /// <value>The custom objects associated with a Zuora standard object.</value>

        [DataMember(Name="custom_objects")]
        public OneOfsubscriptionItemCustomObjects CustomObjects { get; private set; }

        /// <summary>
        /// Human-readable identifier of the subscription item. It can be user-supplied.
        /// </summary>
        /// <value>Human-readable identifier of the subscription item. It can be user-supplied.</value>

        [DataMember(Name="subscription_item_number")]
        public string SubscriptionItemNumber { get; set; }

        /// <summary>
        /// The name of the subscription item.
        /// </summary>
        /// <value>The name of the subscription item.</value>

        [DataMember(Name="name")]
        public string Name { get; set; }

        /// <summary>
        /// An arbitrary string attached to the object. Often useful for displaying to users.
        /// </summary>
        /// <value>An arbitrary string attached to the object. Often useful for displaying to users.</value>

        [DataMember(Name="description")]
        public string Description { get; set; }

        /// <summary>
        /// Identifier of the product with which this subscription is associated.
        /// </summary>
        /// <value>Identifier of the product with which this subscription is associated.</value>

        [DataMember(Name="product_id")]
        public string ProductId { get; set; }

        /// <summary>
        /// The date through which a customer has been billed for the subscription item.
        /// </summary>
        /// <value>The date through which a customer has been billed for the subscription item.</value>

        [DataMember(Name="charged_through_date")]
        public DateTime? ChargedThroughDate { get; set; }

        /// <summary>
        /// Gets or Sets Recurring
        /// </summary>

        [DataMember(Name="recurring")]
        public Recurring Recurring { get; set; }

        /// <summary>
        /// Indicates whether the price is active and can be used for new purchases.
        /// </summary>
        /// <value>Indicates whether the price is active and can be used for new purchases.</value>

        [DataMember(Name="active")]
        public bool? Active { get; set; }

        /// <summary>
        /// Based on the current date to populate a state field with the enumeration: [inactive, active, expired] where inactive would represent charge segments with a start_date in the future and expired charge segments with an end_date in the past.
        /// </summary>
        /// <value>Based on the current date to populate a state field with the enumeration: [inactive, active, expired] where inactive would represent charge segments with a start_date in the future and expired charge segments with an end_date in the past.</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum StateEnum
        {
            /// <summary>
            /// Enum InactiveEnum for inactive
            /// </summary>
            [EnumMember(Value = "inactive")]
            InactiveEnum = 0,
            /// <summary>
            /// Enum ActiveEnum for active
            /// </summary>
            [EnumMember(Value = "active")]
            ActiveEnum = 1,
            /// <summary>
            /// Enum ExpiredEnum for expired
            /// </summary>
            [EnumMember(Value = "expired")]
            ExpiredEnum = 2        }

        /// <summary>
        /// Based on the current date to populate a state field with the enumeration: [inactive, active, expired] where inactive would represent charge segments with a start_date in the future and expired charge segments with an end_date in the past.
        /// </summary>
        /// <value>Based on the current date to populate a state field with the enumeration: [inactive, active, expired] where inactive would represent charge segments with a start_date in the future and expired charge segments with an end_date in the past.</value>

        [DataMember(Name="state")]
        public StateEnum? State { get; set; }

        /// <summary>
        /// Specifies when to start billing your customer.
        /// </summary>
        /// <value>Specifies when to start billing your customer.</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum StartEventEnum
        {
            /// <summary>
            /// Enum ContractEffectiveEnum for contract_effective
            /// </summary>
            [EnumMember(Value = "contract_effective")]
            ContractEffectiveEnum = 0,
            /// <summary>
            /// Enum ServiceActivationEnum for service_activation
            /// </summary>
            [EnumMember(Value = "service_activation")]
            ServiceActivationEnum = 1,
            /// <summary>
            /// Enum CustomerAcceptanceEnum for customer_acceptance
            /// </summary>
            [EnumMember(Value = "customer_acceptance")]
            CustomerAcceptanceEnum = 2,
            /// <summary>
            /// Enum SpecificDateEnum for specific_date
            /// </summary>
            [EnumMember(Value = "specific_date")]
            SpecificDateEnum = 3        }

        /// <summary>
        /// Specifies when to start billing your customer.
        /// </summary>
        /// <value>Specifies when to start billing your customer.</value>

        [DataMember(Name="start_event")]
        public StartEventEnum? StartEvent { get; set; }

        /// <summary>
        /// Specifies the kind of tiering.
        /// </summary>
        /// <value>Specifies the kind of tiering.</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum TiersModeEnum
        {
            /// <summary>
            /// Enum GraduatedEnum for graduated
            /// </summary>
            [EnumMember(Value = "graduated")]
            GraduatedEnum = 0,
            /// <summary>
            /// Enum VolumeEnum for volume
            /// </summary>
            [EnumMember(Value = "volume")]
            VolumeEnum = 1,
            /// <summary>
            /// Enum HighWatermarkVolumeEnum for high_watermark_volume
            /// </summary>
            [EnumMember(Value = "high_watermark_volume")]
            HighWatermarkVolumeEnum = 2,
            /// <summary>
            /// Enum HighWatermarkGraduatedEnum for high_watermark_graduated
            /// </summary>
            [EnumMember(Value = "high_watermark_graduated")]
            HighWatermarkGraduatedEnum = 3,
            /// <summary>
            /// Enum GraduatedWithOverageEnum for graduated_with_overage
            /// </summary>
            [EnumMember(Value = "graduated_with_overage")]
            GraduatedWithOverageEnum = 4        }

        /// <summary>
        /// Specifies the kind of tiering.
        /// </summary>
        /// <value>Specifies the kind of tiering.</value>

        [DataMember(Name="tiers_mode")]
        public TiersModeEnum? TiersMode { get; set; }

        /// <summary>
        /// Gets or Sets Tiers
        /// </summary>

        [DataMember(Name="tiers")]
        public List<ItemTier> Tiers { get; set; }

        /// <summary>
        /// A tax code identifier. If the &#x60;tax_code&#x60; of a price is not provided when you create or override a price, Zuora will treat the charged amount as non-taxable. If this code is provide, Zuora considers that this price is taxable and the charged amount will be handled accordingly.
        /// </summary>
        /// <value>A tax code identifier. If the &#x60;tax_code&#x60; of a price is not provided when you create or override a price, Zuora will treat the charged amount as non-taxable. If this code is provide, Zuora considers that this price is taxable and the charged amount will be handled accordingly.</value>

        [DataMember(Name="tax_code")]
        public string TaxCode { get; set; }

        /// <summary>
        /// If this field is set to &#x60;true&#x60;, it indicates that amounts are inclusive of tax.
        /// </summary>
        /// <value>If this field is set to &#x60;true&#x60;, it indicates that amounts are inclusive of tax.</value>

        [DataMember(Name="tax_inclusive")]
        public bool? TaxInclusive { get; set; }

        /// <summary>
        /// A configured unit of measure. This field is required for per-unit prices.
        /// </summary>
        /// <value>A configured unit of measure. This field is required for per-unit prices.</value>

        [DataMember(Name="unit_of_measure")]
        public string UnitOfMeasure { get; set; }

        /// <summary>
        /// Quantity of the product to which your customers subscribe.
        /// </summary>
        /// <value>Quantity of the product to which your customers subscribe.</value>

        [DataMember(Name="quantity")]
        public decimal? Quantity { get; set; }

        /// <summary>
        /// The amount of the price. Specify this field if you want to override the original price with a flat-fee price
        /// </summary>
        /// <value>The amount of the price. Specify this field if you want to override the original price with a flat-fee price</value>

        [DataMember(Name="amount")]
        public decimal? Amount { get; set; }

        /// <summary>
        /// The unit amount of the price. Specify this field if you want to override the original price with a per-unit price.
        /// </summary>
        /// <value>The unit amount of the price. Specify this field if you want to override the original price with a per-unit price.</value>

        [DataMember(Name="unit_amount")]
        public decimal? UnitAmount { get; set; }

        /// <summary>
        /// Discount amount. Specify this field if you offer an amount-based discount.
        /// </summary>
        /// <value>Discount amount. Specify this field if you offer an amount-based discount.</value>

        [DataMember(Name="discount_amount")]
        public decimal? DiscountAmount { get; set; }

        /// <summary>
        /// Discount percent. Specify this field if you offer a percentage-based discount.
        /// </summary>
        /// <value>Discount percent. Specify this field if you offer a percentage-based discount.</value>

        [DataMember(Name="discount_percent")]
        public decimal? DiscountPercent { get; set; }

        /// <summary>
        /// Gets or Sets ApplyDiscountTo
        /// </summary>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum ApplyDiscountToEnum
        {
            /// <summary>
            /// Enum OneTimeEnum for one_time
            /// </summary>
            [EnumMember(Value = "one_time")]
            OneTimeEnum = 0,
            /// <summary>
            /// Enum RecurringEnum for recurring
            /// </summary>
            [EnumMember(Value = "recurring")]
            RecurringEnum = 1,
            /// <summary>
            /// Enum UsageEnum for usage
            /// </summary>
            [EnumMember(Value = "usage")]
            UsageEnum = 2        }

        /// <summary>
        /// Any combination of one_time, recurring and plan.
        /// </summary>
        /// <value>Any combination of one_time, recurring and plan.</value>

        [DataMember(Name="apply_discount_to")]
        public List<ApplyDiscountToEnum> ApplyDiscountTo { get; set; }

        /// <summary>
        /// Specifies at what level a discount should be applied: one of account, subscription or plan.
        /// </summary>
        /// <value>Specifies at what level a discount should be applied: one of account, subscription or plan.</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum DiscountLevelEnum
        {
            /// <summary>
            /// Enum AccountEnum for account
            /// </summary>
            [EnumMember(Value = "account")]
            AccountEnum = 0,
            /// <summary>
            /// Enum SubscriptionEnum for subscription
            /// </summary>
            [EnumMember(Value = "subscription")]
            SubscriptionEnum = 1,
            /// <summary>
            /// Enum PlanEnum for plan
            /// </summary>
            [EnumMember(Value = "plan")]
            PlanEnum = 2        }

        /// <summary>
        /// Specifies at what level a discount should be applied: one of account, subscription or plan.
        /// </summary>
        /// <value>Specifies at what level a discount should be applied: one of account, subscription or plan.</value>

        [DataMember(Name="discount_level")]
        public DiscountLevelEnum? DiscountLevel { get; set; }

        /// <summary>
        /// Specifies the base interval of the price the subscriber is subscribed to. If not provided, this field defaults to `billing_period`.
        /// </summary>
        /// <value>Specifies the base interval of the price the subscriber is subscribed to. If not provided, this field defaults to `billing_period`.</value>
        [JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public enum PriceBaseIntervalEnum
        {
            /// <summary>
            /// Enum MonthEnum for month
            /// </summary>
            [EnumMember(Value = "month")]
            MonthEnum = 0,
            /// <summary>
            /// Enum BillingPeriodEnum for billing_period
            /// </summary>
            [EnumMember(Value = "billing_period")]
            BillingPeriodEnum = 1,
            /// <summary>
            /// Enum WeekEnum for week
            /// </summary>
            [EnumMember(Value = "week")]
            WeekEnum = 2        }

        /// <summary>
        /// Specifies the base interval of the price the subscriber is subscribed to. If not provided, this field defaults to &#x60;billing_period&#x60;.
        /// </summary>
        /// <value>Specifies the base interval of the price the subscriber is subscribed to. If not provided, this field defaults to &#x60;billing_period&#x60;.</value>

        [DataMember(Name="price_base_interval")]
        public PriceBaseIntervalEnum? PriceBaseInterval { get; set; }

        /// <summary>
        /// Gets or Sets Overage
        /// </summary>

        [DataMember(Name="overage")]
        public Overage Overage { get; set; }

        /// <summary>
        /// Charge model of the price. See [Charge models](https://knowledgecenter.zuora.com/Billing/Subscriptions/Product_Catalog/B_Charge_Models) for more information.
        /// </summary>
        /// <value>Charge model of the price. See [Charge models](https://knowledgecenter.zuora.com/Billing/Subscriptions/Product_Catalog/B_Charge_Models) for more information.</value>

        [DataMember(Name="charge_model")]
        public string ChargeModel { get; set; }

        /// <summary>
        /// Type of the charge. It can be one of the following types: one-time, recurring, or usage.
        /// </summary>
        /// <value>Type of the charge. It can be one of the following types: one-time, recurring, or usage.</value>

        [DataMember(Name="charge_type")]
        public string ChargeType { get; set; }

        /// <summary>
        /// Identifier of the price.
        /// </summary>
        /// <value>Identifier of the price.</value>

        [DataMember(Name="price_id")]
        public string PriceId { get; set; }

        /// <summary>
        /// Gets or Sets Price
        /// </summary>

        [DataMember(Name="price")]
        public Price Price { get; set; }

        /// <summary>
        /// Identifier of the subscription plan this subscription item belongs to.
        /// </summary>
        /// <value>Identifier of the subscription plan this subscription item belongs to.</value>

        [DataMember(Name="subscription_plan_id")]
        public string SubscriptionPlanId { get; set; }

        /// <summary>
        /// Gets or Sets SubscriptionPlan
        /// </summary>

        [DataMember(Name="subscription_plan")]
        public SubscriptionPlan SubscriptionPlan { get; set; }

        /// <summary>
        /// The date when the subscription item starts.
        /// </summary>
        /// <value>The date when the subscription item starts.</value>

        [DataMember(Name="start_date")]
        public DateTime? StartDate { get; private set; }

        /// <summary>
        /// The date when the subscription item ends.
        /// </summary>
        /// <value>The date when the subscription item ends.</value>

        [DataMember(Name="end_date")]
        public DateTime? EndDate { get; private set; }

        /// <summary>
        /// The date until when charges are processed. When billing takes place in arrears, such as usage-based prices, this field value is the the same as the &#x60;ChargedThroughDate&#x60; value. This date is the earliest date when a charge can be amended.
        /// </summary>
        /// <value>The date until when charges are processed. When billing takes place in arrears, such as usage-based prices, this field value is the the same as the &#x60;ChargedThroughDate&#x60; value. This date is the earliest date when a charge can be amended.</value>

        [DataMember(Name="processed_through_date")]
        public DateTime? ProcessedThroughDate { get; private set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SubscriptionItem {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  UpdatedById: ").Append(UpdatedById).Append("\n");
            sb.Append("  UpdatedTime: ").Append(UpdatedTime).Append("\n");
            sb.Append("  CreatedById: ").Append(CreatedById).Append("\n");
            sb.Append("  CreatedTime: ").Append(CreatedTime).Append("\n");
            sb.Append("  CustomFields: ").Append(CustomFields).Append("\n");
            sb.Append("  CustomObjects: ").Append(CustomObjects).Append("\n");
            sb.Append("  SubscriptionItemNumber: ").Append(SubscriptionItemNumber).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  ProductId: ").Append(ProductId).Append("\n");
            sb.Append("  ChargedThroughDate: ").Append(ChargedThroughDate).Append("\n");
            sb.Append("  Recurring: ").Append(Recurring).Append("\n");
            sb.Append("  Active: ").Append(Active).Append("\n");
            sb.Append("  State: ").Append(State).Append("\n");
            sb.Append("  StartEvent: ").Append(StartEvent).Append("\n");
            sb.Append("  TiersMode: ").Append(TiersMode).Append("\n");
            sb.Append("  Tiers: ").Append(Tiers).Append("\n");
            sb.Append("  TaxCode: ").Append(TaxCode).Append("\n");
            sb.Append("  TaxInclusive: ").Append(TaxInclusive).Append("\n");
            sb.Append("  UnitOfMeasure: ").Append(UnitOfMeasure).Append("\n");
            sb.Append("  Quantity: ").Append(Quantity).Append("\n");
            sb.Append("  Amount: ").Append(Amount).Append("\n");
            sb.Append("  UnitAmount: ").Append(UnitAmount).Append("\n");
            sb.Append("  DiscountAmount: ").Append(DiscountAmount).Append("\n");
            sb.Append("  DiscountPercent: ").Append(DiscountPercent).Append("\n");
            sb.Append("  ApplyDiscountTo: ").Append(ApplyDiscountTo).Append("\n");
            sb.Append("  DiscountLevel: ").Append(DiscountLevel).Append("\n");
            sb.Append("  PriceBaseInterval: ").Append(PriceBaseInterval).Append("\n");
            sb.Append("  Overage: ").Append(Overage).Append("\n");
            sb.Append("  ChargeModel: ").Append(ChargeModel).Append("\n");
            sb.Append("  ChargeType: ").Append(ChargeType).Append("\n");
            sb.Append("  PriceId: ").Append(PriceId).Append("\n");
            sb.Append("  Price: ").Append(Price).Append("\n");
            sb.Append("  SubscriptionPlanId: ").Append(SubscriptionPlanId).Append("\n");
            sb.Append("  SubscriptionPlan: ").Append(SubscriptionPlan).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  EndDate: ").Append(EndDate).Append("\n");
            sb.Append("  ProcessedThroughDate: ").Append(ProcessedThroughDate).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((SubscriptionItem)obj);
        }

        /// <summary>
        /// Returns true if SubscriptionItem instances are equal
        /// </summary>
        /// <param name="other">Instance of SubscriptionItem to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SubscriptionItem other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    Id == other.Id ||
                    Id != null &&
                    Id.Equals(other.Id)
                ) && 
                (
                    UpdatedById == other.UpdatedById ||
                    UpdatedById != null &&
                    UpdatedById.Equals(other.UpdatedById)
                ) && 
                (
                    UpdatedTime == other.UpdatedTime ||
                    UpdatedTime != null &&
                    UpdatedTime.Equals(other.UpdatedTime)
                ) && 
                (
                    CreatedById == other.CreatedById ||
                    CreatedById != null &&
                    CreatedById.Equals(other.CreatedById)
                ) && 
                (
                    CreatedTime == other.CreatedTime ||
                    CreatedTime != null &&
                    CreatedTime.Equals(other.CreatedTime)
                ) && 
                (
                    CustomFields == other.CustomFields ||
                    CustomFields != null &&
                    CustomFields.SequenceEqual(other.CustomFields)
                ) && 
                (
                    CustomObjects == other.CustomObjects ||
                    CustomObjects != null &&
                    CustomObjects.Equals(other.CustomObjects)
                ) && 
                (
                    SubscriptionItemNumber == other.SubscriptionItemNumber ||
                    SubscriptionItemNumber != null &&
                    SubscriptionItemNumber.Equals(other.SubscriptionItemNumber)
                ) && 
                (
                    Name == other.Name ||
                    Name != null &&
                    Name.Equals(other.Name)
                ) && 
                (
                    Description == other.Description ||
                    Description != null &&
                    Description.Equals(other.Description)
                ) && 
                (
                    ProductId == other.ProductId ||
                    ProductId != null &&
                    ProductId.Equals(other.ProductId)
                ) && 
                (
                    ChargedThroughDate == other.ChargedThroughDate ||
                    ChargedThroughDate != null &&
                    ChargedThroughDate.Equals(other.ChargedThroughDate)
                ) && 
                (
                    Recurring == other.Recurring ||
                    Recurring != null &&
                    Recurring.Equals(other.Recurring)
                ) && 
                (
                    Active == other.Active ||
                    Active != null &&
                    Active.Equals(other.Active)
                ) && 
                (
                    State == other.State ||
                    State != null &&
                    State.Equals(other.State)
                ) && 
                (
                    StartEvent == other.StartEvent ||
                    StartEvent != null &&
                    StartEvent.Equals(other.StartEvent)
                ) && 
                (
                    TiersMode == other.TiersMode ||
                    TiersMode != null &&
                    TiersMode.Equals(other.TiersMode)
                ) && 
                (
                    Tiers == other.Tiers ||
                    Tiers != null &&
                    Tiers.SequenceEqual(other.Tiers)
                ) && 
                (
                    TaxCode == other.TaxCode ||
                    TaxCode != null &&
                    TaxCode.Equals(other.TaxCode)
                ) && 
                (
                    TaxInclusive == other.TaxInclusive ||
                    TaxInclusive != null &&
                    TaxInclusive.Equals(other.TaxInclusive)
                ) && 
                (
                    UnitOfMeasure == other.UnitOfMeasure ||
                    UnitOfMeasure != null &&
                    UnitOfMeasure.Equals(other.UnitOfMeasure)
                ) && 
                (
                    Quantity == other.Quantity ||
                    Quantity != null &&
                    Quantity.Equals(other.Quantity)
                ) && 
                (
                    Amount == other.Amount ||
                    Amount != null &&
                    Amount.Equals(other.Amount)
                ) && 
                (
                    UnitAmount == other.UnitAmount ||
                    UnitAmount != null &&
                    UnitAmount.Equals(other.UnitAmount)
                ) && 
                (
                    DiscountAmount == other.DiscountAmount ||
                    DiscountAmount != null &&
                    DiscountAmount.Equals(other.DiscountAmount)
                ) && 
                (
                    DiscountPercent == other.DiscountPercent ||
                    DiscountPercent != null &&
                    DiscountPercent.Equals(other.DiscountPercent)
                ) && 
                (
                    ApplyDiscountTo == other.ApplyDiscountTo ||
                    ApplyDiscountTo != null &&
                    ApplyDiscountTo.SequenceEqual(other.ApplyDiscountTo)
                ) && 
                (
                    DiscountLevel == other.DiscountLevel ||
                    DiscountLevel != null &&
                    DiscountLevel.Equals(other.DiscountLevel)
                ) && 
                (
                    PriceBaseInterval == other.PriceBaseInterval ||
                    PriceBaseInterval != null &&
                    PriceBaseInterval.Equals(other.PriceBaseInterval)
                ) && 
                (
                    Overage == other.Overage ||
                    Overage != null &&
                    Overage.Equals(other.Overage)
                ) && 
                (
                    ChargeModel == other.ChargeModel ||
                    ChargeModel != null &&
                    ChargeModel.Equals(other.ChargeModel)
                ) && 
                (
                    ChargeType == other.ChargeType ||
                    ChargeType != null &&
                    ChargeType.Equals(other.ChargeType)
                ) && 
                (
                    PriceId == other.PriceId ||
                    PriceId != null &&
                    PriceId.Equals(other.PriceId)
                ) && 
                (
                    Price == other.Price ||
                    Price != null &&
                    Price.Equals(other.Price)
                ) && 
                (
                    SubscriptionPlanId == other.SubscriptionPlanId ||
                    SubscriptionPlanId != null &&
                    SubscriptionPlanId.Equals(other.SubscriptionPlanId)
                ) && 
                (
                    SubscriptionPlan == other.SubscriptionPlan ||
                    SubscriptionPlan != null &&
                    SubscriptionPlan.Equals(other.SubscriptionPlan)
                ) && 
                (
                    StartDate == other.StartDate ||
                    StartDate != null &&
                    StartDate.Equals(other.StartDate)
                ) && 
                (
                    EndDate == other.EndDate ||
                    EndDate != null &&
                    EndDate.Equals(other.EndDate)
                ) && 
                (
                    ProcessedThroughDate == other.ProcessedThroughDate ||
                    ProcessedThroughDate != null &&
                    ProcessedThroughDate.Equals(other.ProcessedThroughDate)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (Id != null)
                    hashCode = hashCode * 59 + Id.GetHashCode();
                    if (UpdatedById != null)
                    hashCode = hashCode * 59 + UpdatedById.GetHashCode();
                    if (UpdatedTime != null)
                    hashCode = hashCode * 59 + UpdatedTime.GetHashCode();
                    if (CreatedById != null)
                    hashCode = hashCode * 59 + CreatedById.GetHashCode();
                    if (CreatedTime != null)
                    hashCode = hashCode * 59 + CreatedTime.GetHashCode();
                    if (CustomFields != null)
                    hashCode = hashCode * 59 + CustomFields.GetHashCode();
                    if (CustomObjects != null)
                    hashCode = hashCode * 59 + CustomObjects.GetHashCode();
                    if (SubscriptionItemNumber != null)
                    hashCode = hashCode * 59 + SubscriptionItemNumber.GetHashCode();
                    if (Name != null)
                    hashCode = hashCode * 59 + Name.GetHashCode();
                    if (Description != null)
                    hashCode = hashCode * 59 + Description.GetHashCode();
                    if (ProductId != null)
                    hashCode = hashCode * 59 + ProductId.GetHashCode();
                    if (ChargedThroughDate != null)
                    hashCode = hashCode * 59 + ChargedThroughDate.GetHashCode();
                    if (Recurring != null)
                    hashCode = hashCode * 59 + Recurring.GetHashCode();
                    if (Active != null)
                    hashCode = hashCode * 59 + Active.GetHashCode();
                    if (State != null)
                    hashCode = hashCode * 59 + State.GetHashCode();
                    if (StartEvent != null)
                    hashCode = hashCode * 59 + StartEvent.GetHashCode();
                    if (TiersMode != null)
                    hashCode = hashCode * 59 + TiersMode.GetHashCode();
                    if (Tiers != null)
                    hashCode = hashCode * 59 + Tiers.GetHashCode();
                    if (TaxCode != null)
                    hashCode = hashCode * 59 + TaxCode.GetHashCode();
                    if (TaxInclusive != null)
                    hashCode = hashCode * 59 + TaxInclusive.GetHashCode();
                    if (UnitOfMeasure != null)
                    hashCode = hashCode * 59 + UnitOfMeasure.GetHashCode();
                    if (Quantity != null)
                    hashCode = hashCode * 59 + Quantity.GetHashCode();
                    if (Amount != null)
                    hashCode = hashCode * 59 + Amount.GetHashCode();
                    if (UnitAmount != null)
                    hashCode = hashCode * 59 + UnitAmount.GetHashCode();
                    if (DiscountAmount != null)
                    hashCode = hashCode * 59 + DiscountAmount.GetHashCode();
                    if (DiscountPercent != null)
                    hashCode = hashCode * 59 + DiscountPercent.GetHashCode();
                    if (ApplyDiscountTo != null)
                    hashCode = hashCode * 59 + ApplyDiscountTo.GetHashCode();
                    if (DiscountLevel != null)
                    hashCode = hashCode * 59 + DiscountLevel.GetHashCode();
                    if (PriceBaseInterval != null)
                    hashCode = hashCode * 59 + PriceBaseInterval.GetHashCode();
                    if (Overage != null)
                    hashCode = hashCode * 59 + Overage.GetHashCode();
                    if (ChargeModel != null)
                    hashCode = hashCode * 59 + ChargeModel.GetHashCode();
                    if (ChargeType != null)
                    hashCode = hashCode * 59 + ChargeType.GetHashCode();
                    if (PriceId != null)
                    hashCode = hashCode * 59 + PriceId.GetHashCode();
                    if (Price != null)
                    hashCode = hashCode * 59 + Price.GetHashCode();
                    if (SubscriptionPlanId != null)
                    hashCode = hashCode * 59 + SubscriptionPlanId.GetHashCode();
                    if (SubscriptionPlan != null)
                    hashCode = hashCode * 59 + SubscriptionPlan.GetHashCode();
                    if (StartDate != null)
                    hashCode = hashCode * 59 + StartDate.GetHashCode();
                    if (EndDate != null)
                    hashCode = hashCode * 59 + EndDate.GetHashCode();
                    if (ProcessedThroughDate != null)
                    hashCode = hashCode * 59 + ProcessedThroughDate.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(SubscriptionItem left, SubscriptionItem right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(SubscriptionItem left, SubscriptionItem right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
